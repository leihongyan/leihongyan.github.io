---
layout: post
title: 解决浮点误差
date: 2018-1-18
tags: js
---

	众所周知，JavaScript 浮点数运算时经常遇到会 0.000000001 和 0.999999999 这样奇怪的结果，如 0.1+0.2=0.30000000000000004、1-0.9=0.09999999999999998，很多人知道这是浮点数误差问题，但具体原因就说不清楚了。本文帮你理清这背后的原理以及解决方案，还会向你解释JS中

### 为什么 0.1+0.2=0.30000000000000004？
计算步骤为：
```
// 0.1 和 0.2 都转化成二进制后再进行运算
0.00011001100110011001100110011001100110011001100110011010 +
0.0011001100110011001100110011001100110011001100110011010 =
0.0100110011001100110011001100110011001100110011001100111

// 转成十进制正好是 0.30000000000000004
```

### toPrecision vs toFixed
数据处理时，这两个函数很容易混淆。它们的共同点是把数字转成字符串供展示使用。注意在计算的中间过程不要使用，只用于最终结果。
不同点就需要注意一下：
* `toPrecision` 是处理精度，精度是从左至右第一个不为0的数开始数起
* `toFixed` 是小数点后指定位数取整，从小数点开始数起。

### 解决方案
理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果。

#### 数据展示类
当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：
parseFloat 转成数字后再显示，如下：
```
parseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True
```
封装成方法就是：
```
function strip(num, precision = 12) {
  return +parseFloat(num.toPrecision(precision));
}
```
为什么选择 12 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。

### 数据运算类

对于运算类操作，如`+-*/`,就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。以加法为例：
```
/**
 * 精确加法
 */
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length;
  const num2Digits = (num2.toString().split('.')[1] || '').length;
  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}
```